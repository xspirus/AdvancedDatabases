\documentclass{ntua}

\title{Αναφορά Άσκησης MapReduce}
\author{Δοντάς Σπυρίδων \& Τσιούρβας Αστέριος}

\pagestyle{fancy}

\renewcommand{\headrulewidth}{0.5pt}
\renewcommand{\footrulewidth}{0.5pt}

\fancyhead{}
\fancyhead[L]{Αναφορά Άσκησης MapReduce}
\fancyhead[R]{Προχωρημένα Θέματα Βάσεων Δεδομένων}
\fancyfoot{}
\fancyfoot[C]{Σελίδα \thepage}

\usepackage{titlesec}

\begin{document}

\begin{titlepage}
	\vspace{\fill}
	\centering
	\includegraphics[scale=0.4]{ntua.jpg}
	\par\vspace{1cm}
	{\scshape\Huge\bfseries Εθνικο Μετσοβιο Πολυτεχνειο}
	\par\vspace{1cm}
	{\scshape\LARGE\bfseries Ηλετρολογων Μηχανικων \& \\ Μηχανικων Υπολογιστων}
	\par\vspace{3cm}
	{\Large\bfseries Προχωρημένα Θέματα Βάσεων Δεδομένων}
	\par\vspace{1cm}
	{\Large\bfseries \thetitle}
	\par\vspace{1cm}
	\large
	\begin{tabular}[H]{cc}
		Δοντάς Σπυρίδων & Τσιούρβας Αστέριος \\
		9ο εξάμηνο & 9ο εξάμηνο \\
		03114141 & 03114133
	\end{tabular}
	\par\vspace{3cm}
	\rule[.5\baselineskip]{\textwidth}{.5pt}
	{\large Αθήνα, Φεβρουάριος 2019}
	\vspace{\fill}
\end{titlepage}

\tableofcontents

\newpage

\justify

\section{Αναλυτική Επεξεργασία Δεδομένων}

\subsection{Μεθοδολογία}

\subsubsection{Ερώτημα Α}
Το πρώτο ερώτημα ζητά να βρεθεί η μέση διάρκεια διαδρομής (σε λεπτά) ανά ώρα έναρξης της διαδρομής και να 
ταξινομιθεί το αποτέλεσμα με βάση την ώρα έναρξης σε αύξουσα σειρά. Για την επίλυση του ερωτήματος, διαβάζουμε τα δεδομένα απο τό αρχείο yellow\_tripdata\_1m.csv και χρησιμοποιούμε μία φάση \textbf{MapReduceMap}, όπως αναφέρεται και στη σχετική υπόδειξη.\\ \\ 
Στη φάση \textbf{Map}, για κάθε εγγραφή του αρχείου υπολογίζουμε τη χρονική διάρκεια κάθε διαδρομής σε λεπτά χρησιμοποιόντας την ημερομηνία και ώρα έναρξης και λήξης της και κάνουμε emit tuples της μορφής $( key = start\_hour, value = duration)$. \\ \\
Στη φάση \textbf{Reduce}, υπολογίζουμε το συνολικό άθροισμα των διαδρομών ανά ώρα έναρξης και 
και για κάθε ώρα έναρξης κάνουμε emit tuples της μορφής $( key = start\_hour, value = (total\_trips,duration))$.\\ \\ 
Στη φάση \textbf{Map}, για κάθε tuple υπολογίζουμε τη μέση διάρκεια διαδρομής ανά ώρα έναρξης και κάνουμε emit tuples της μορφής $( key = start\_hour, value = avg\_duration)$. Τα δεδομένα μας είναι στη μορφή που επιθυμούμε.  \\ \\
Τέλος, ταξινομούμε τα αποτελέσματα με βάση την ώρα έναρξης της διαδρομής και τα γράφουμε σε αρχείο και τα εμφανίζουμε.
\subsubsection{Ερώτημα Β}
Το πρώτο ερώτημα ζητά να βρεθεί το μέγιστο ποσό που πληρώθηκε σε μία διαδρομή σε κάθε εταιρία ταξί. Για την επίλυση του ερωτήματος, διαβάζουμε τα δεδομένα από τα αρχεία yellow\_tripdata\_1m.csv και yellow\_tripvendors\_1m.csv. Χρησιμοποιούμε μία φάση \textbf{MapJoin} και έπειτα άλλη μία \textbf{MapReduce}. \\ \\ 
Στη φάση \textbf{Map}, για κάθε εγγραφή του yellow\_tripdata\_1m.csv κάνουμε emit tuples της μορφής $( key = trip\_id, value = company\_id)$, ενώ για κάθε εγγραφή του yellow\_tripvendors\_1m.csv κάνουμε emit tuples της μορφής $( key = trip\_id, value = amount)$. \\ \\
Στη συνέχεια, πραγματοποιούμε inner join με βάση το $trip\_id$ μεταξύ των δύο παραπάνω $RDDs$.\\ \\ 
Στη φάση \textbf{Map}, για κάθε tuple της μορφής$( key = trip\_id, value = (company\_id,amount))$ κάνουμε emit tuples της μορφής $( key = company\_id, value = amount)$.  \\ \\
Στη φάση \textbf{Reduce}, βρίσκουμε το μέγιστο ποσό ανά εταιρία και κάνουμε emit tuples της μορφής $( key = company\_id, value = max\_amount)$. \\ \\
Τέλος, ταξινομούμε τα αποτελέσματα με βάση το key = $company\_id$, τα γράφουμε σε αρχείο και τα εμφανίζουμε.
\subsection{Ψευδοκώδικας}

\subsubsection{Ερώτημα Α}

\subsubsection{Ερώτημα Β}

\newpage

\section{Machine Learning - Εκτέλεση k-Means με fixed k}

\subsection{Μεθοδολογία}
H άσκηση ζητάει χρησιμοποιώντας τα δεδομένα του πρώτου ερωτηματος να βρούμε τις κεντρικές συντεταγμένες των top 5 περιοχών επιβίβασης πελατών με την χρήση του αλγορίθμου $k-means$. Για την επίλυση, διαβάζουμε τα δεδομένα από το αρχείο yellow\_tripdata\_1m.csv. \\ \\
Αρχικα, για κάθε εγγραφή του αρχείου yellow\_tripdata\_1m.csv κρατάμε τις συντεταγμένες, αρχικοποιούμε μεταβλητές και ορίζουμε τα κέντρα ως τις πρώτες 5 τιμές του αρχείου.\\ \\ 
Σε κάθε επανάληψη, εφαρμόζουμε μία φάση \textbf{Map} για να δημιουργήσουμε ένα RDD με τις συντεταγμένες κάθε σημείου και ένα αντίγραφο των κέντρων. Έπειτα, εφαρμόζουμε μία φάση \textbf{Map} και κάνουμε emit tuples της μορφής $( key = closest\_cluster\_id, value = coordinates)$. Στη συνέχεια, εφαρμόζουμε μία φάση \textbf{MapReduceMap}, για την εύρεση των νέων κέντρων με βάση τους μέσους όρους ανά συντεταγμένη (η διαδικασία είναι παρόμοια με την εύρεση του μέσου όρου στην άσκηση 1 με τη διαφορά ότι εδώ βρίσκουμε μέσο όρο σε πολλά στοιχεία ανά στοιχείο). \\ \\ 
Μετά το πέρας των $5$ επαναλήψεων τα έχουμε βρει τα τελικά κέντρα του αλγορίθμου $k-means$, τα γράφουμε σε αρχείο και τα εμφανίζουμε.  
\subsection{Ψευδοκώδικας}

\newpage

\section{Γράφοι - PageRank Computation}

\subsection{Μεθοδολογία}
H άσκηση ζητάει να βρούμε το $PageRank$ κάθε κόμβου που βρίσκεται στα δεδομένα της Google με βάση τον επαναληπτικό τύπο που δίνεται στην εκφώνηση. Για την επίλυση του ερωτήματος, διαβάζουμε τα δεδομένα από το αρχείο web-Google.txt.\\ \\
Αρχικά, εφαρμόζουμε μία φάση \textbf{Map} και για να δημιουργήσουμε ένα RDD που περιέχει σε tuples τα from και to ids των nodes. Έπειτα, πραγματοποιούμε \textbf{groupByKey} προκειμένου να ομαδοποιήσουμε τα δεδομένα σε tuples της μορφής $( key = from\_id, value = list\_of\_to\_ids)$ και πραγματοποιούμε τις αρχικοποιήσεις παράγοντας tuples της μορφής $( key = id, value = score)$.\\ \\
Σε κάθε επανάληψη, εφαρμόζουμε μία φάση \textbf{Join} για να δημιουργήσουμε tuples της μορφής $( key = from\_id, value = (list\_of\_to\_ids,score))$. Έπειτα, εφαρμόζουμε μία φάση \textbf{FlatMapReduceMap} έτσι ώστε να αποκτήσουμε - από τη φάση \textbf{FlatMap} - tuples της μορφής $( key = from\_id, value = a\_fraction\_of\_outbounds\_links)$ , δηλαδή tuples της μορφής $(id, \frac{PR(pj)}{L(pj)})$, στη συνέχεια - φάση \textbf{Reduce} - να υπολογίσουμε tuples της μορφής $( key = from\_id, value =\sum_{pj\in{M(pi)}}^{} \frac{PR(pj)}{L(pj)}) $ και τέλος στη φάση \textbf{Map} εφαρμόζουμε τον τύπο υπολογισμού $PageRank$ και λαμβάνουμε tuples της μορφής $( key = id, value = score)$.\\ \\
Μετά το πέρας των $5$ επαναλήψεων τα έχουμε βρει τα $PageRank$ scores για κάθε $id$, τα ταξινομούμε ως προς $id$, τα γράφουμε σε αρχείο και τα εμφανίζουμε.  
\subsection{Ψευδοκώδικας}

\newpage

\section{Γραμμική Άλγεβρα - Πολλαπλασιασμός Πίνακα}

\subsection{Μεθοδολογία}
H άσκηση ζητάει να υπολογιστεί το γινόμενο δύο πινάκων. Για την επίλυση, διαβάζουμε τα δεδομένα από τα αρχεία Α.csv και B.csv και χρησιμοποιούμε μία φάση \textbf{MapReduceMap}, έπειτα μία φάση \textbf{CartesianProduct} και τέλος μία φάση \textbf{MapMap}  \\ \\
Στη φάση \textbf{Map}, για κάθε εγγραφή του αρχείου A.csv κάνουμε emit tuples της μορφής $( key = row\_id\_of\_A, value =(col\_id\_of\_A,value)$. Επιπλέον, για κάθε εγγραφή του αρχείου Β.csv κάνουμε emit tuples της μορφής $( key = col\_id\_of\_B, value =(row\_id\_of\_B,value)$.  \\ \\
Στη φάση \textbf{Reduce}, για κάθε tuple της πρώτης φάσης αθροίζουμε τα values (ως λίστες) και κάνουμε emit tuples της μορφής $( key = row\_id, value =[(col\_id,value)]$ για την πρώτη περίπτωση και για τη δεύτερη περίπτωση $( key = col\_id, value =[(row\_id,value)]$. \\ \\
Στη φάση \textbf{Map}, για κάθε tuple της πιο πάνω φάσης κάνουμε ταξινόμηση τα values με βάση το $ col\_id$ και κάνουμε emit tuples της μορφής $( key = row\_id, value=[value])$ για την πρώτη περίπτωση, ενώ για τη δεύτερη περίπτωση κάνουμε ταξινόμηση τα values με βάση το $ row\_id$ και κάνουμε emit tuples της μορφής $( key = col\_id, value=[value])$.  \\ \\
Στη φάση \textbf{CartesianProduct}, δημιουργούμε tuples της μορφής $( key = (row\_id\_of\_A,col\_id\_of\_B), value = ([value\_A],[value\_B])$. \\ \\
Τέλος, στη φάση \textbf{MapMap}, υπολογίζουμε την τιμή του στοιχείου της θέσης $ (row\_id\_of\_A,col\_id\_of\_B) $ του τελικού πίνακα, δηλαδή κάνουμε emit tuples της μορφής $( key = (row\_id\_of\_A,col\_id\_of\_B), value = final_value)$. \\ \\
Μετά το πέρας της μεθόδου τα έχουμε βρει τις τιμές του τελικού πίνακα, τα γράφουμε σε αρχείο και τα ταξινομούμε ως προς $(row\_id\_of\_A,col\_id\_of\_B)$.  
\subsection{Ψευδοκώδικας}



\section{Παρατηρήσεις - Επισημάνσεις}

\subsection{Jupyter Notebook}
Για την ευκολότερη και καλύτερη οργάνωση του κώδικά μας εγκαταστήσαμε Jupyter Notebook.
\subsection{Github}
Παρακάτω δίνεται σχετικό link στο Github για τον κώδικα που χρησιμοποιήθηκε 

\end{document}